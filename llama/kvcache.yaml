q = k = v: [bs, seq_len, dim]

# qkv
q = [bs, seq_len, dim] -> [bs, seq_len, dim]
k = [bs, seq_len, dim] -> [bs, seq_len, dim]
v = [bs, seq_len, dim] -> [bs, seq_len, dim]

# head
q = [bs, seq_len, dim] -> [bs, seq_len, head, head_dim]   dim = head * head_dim
k = [bs, seq_len, dim] -> [bs, seq_len, head, head_dim]
v = [bs, seq_len, dim] -> [bs, seq_len, head, head_dim]

# apply_rotary_emb
q = apply_rotary_emb(q)
k = apply_rotary_emb(k)

# kv_cache
k_cache: [bs, cache_len, head, head_dim]
v_cache: [bs, cache_len, head, head_dim]

# kv cat kv_cache
k = k_cache cat k = [bs, cache_len, head, head_dim] cat [bs, seq_len, head, head_dim] = [bs, cache_len+seq_len, head, head_dim]
v = v_cache cat v = [bs, cache_len, head, head_dim] cat [bs, seq_len, head, head_dim] = [bs, cache_len+seq_len, head, head_dim]

# transpose
q = [bs, seq_len, head, head_dim]           -> [bs, head, seq_len, head_dim]
k = [bs, cache_len+seq_len, head, head_dim] -> [bs, head, cache_len+seq_len, head_dim]
v = [bs, cache_len+seq_len, head, head_dim] -> [bs, head, cache_len+seq_len, head_dim]

# attn
attn = q @ k.T = [bs, head, seq_len, head_dim] @ [bs, head, head_dim, cache_len+seq_len] = [bs, head, seq_len, cache_len+seq_len]
attn = attn / sqrt(head_dim)

# add mask
# assume cache_len=3, seq_len=2
# mask: [
#         [0, 0, 0, 0, -inf],
#         [0, 0, 0, 0, 0]
#       ]
mask: [seq_len, cache_len+seq_len]
attn = attn + mask

# softmax
attn = softmax(attn, dim=-1)

# apply attn
x = attn @ v = [bs, head, seq_len, cache_len+seq_len] @ [bs, head, cache_len+seq_len, head_dim] = [bs, head, seq_len, head_dim]

# transpose
x = [bs, head, seq_len, head_dim] -> [bs, seq_len, head, head_dim] -> [bs, seq_len, dim]

# proj
x = [bs, seq_len, dim] -> [bs, seq_len, dim]
